<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta name="referrer" content="no-referrer"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>C#高频语法集锦(一) | Welcome,Guys,Join Me for the AIminminAI Episode!</title><meta name="author" content="Hu hb"><meta name="copyright" content="Hu hb"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="@TOC  前言搞编程的，基础不牢，地动山摇，多多复习哦，与诸君共勉。 一、特征【ObsoleteAttribute】、程序1.[Obsolete(“提示信息”, ture&#x2F;false)]：false&#x2F;true代表是否停止编译，true代表。编译器发出错误提示并停止遍历，否则只发出提示信息不停止编译。提醒旧函数过时，使用新函数：12345[Obsolete(&quot;该函数已">
<meta property="og:type" content="article">
<meta property="og:title" content="C#高频语法集锦(一)">
<meta property="og:url" content="https://ywmhhbaiminminai.gitee.io/2023/08/21/C-%E9%AB%98%E9%A2%91%E8%AF%AD%E6%B3%95%E9%9B%86%E9%94%A6-%E4%B8%80/index.html">
<meta property="og:site_name" content="Welcome,Guys,Join Me for the AIminminAI Episode!">
<meta property="og:description" content="@TOC  前言搞编程的，基础不牢，地动山摇，多多复习哦，与诸君共勉。 一、特征【ObsoleteAttribute】、程序1.[Obsolete(“提示信息”, ture&#x2F;false)]：false&#x2F;true代表是否停止编译，true代表。编译器发出错误提示并停止遍历，否则只发出提示信息不停止编译。提醒旧函数过时，使用新函数：12345[Obsolete(&quot;该函数已">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://ywmhhbaiminminai.gitee.io/img/avatar.jpg">
<meta property="article:published_time" content="2023-08-21T14:36:26.000Z">
<meta property="article:modified_time" content="2023-08-21T15:50:13.126Z">
<meta property="article:author" content="Hu hb">
<meta property="article:tag" content="C#">
<meta property="article:tag" content="高频语法">
<meta property="article:tag" content="集合">
<meta property="article:tag" content="多线程">
<meta property="article:tag" content="反射">
<meta property="article:tag" content="程序集">
<meta property="article:tag" content="特性">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ywmhhbaiminminai.gitee.io/img/avatar.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://ywmhhbaiminminai.gitee.io/2023/08/21/C-%E9%AB%98%E9%A2%91%E8%AF%AD%E6%B3%95%E9%9B%86%E9%94%A6-%E4%B8%80/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  dateSuffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: Hu hb","link":"Link: ","source":"Source: Welcome,Guys,Join Me for the AIminminAI Episode!","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source."}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C#高频语法集锦(一)',
  isPost: true,
  isHome: false,
  isHighlightShrink: true,
  isToc: true,
  postUpdate: '2023-08-21 23:50:13'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">47</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">74</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">61</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home(主页)</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives(那些年的知识归档)</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags(那些年的知识标签)</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories(那些年的工作经验)</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link(那些年的八股与AI)</span></a></div><div class="menus_item"><a class="site-page" href="/game/"><i class="fa-fw fas fa-heart"></i><span> Game(游戏专区，学&amp;玩)</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/JingSeOne.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="Welcome,Guys,Join Me for the AIminminAI Episode!"><span class="site-name">Welcome,Guys,Join Me for the AIminminAI Episode!</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home(主页)</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives(那些年的知识归档)</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags(那些年的知识标签)</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories(那些年的工作经验)</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link(那些年的八股与AI)</span></a></div><div class="menus_item"><a class="site-page" href="/game/"><i class="fa-fw fas fa-heart"></i><span> Game(游戏专区，学&amp;玩)</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C#高频语法集锦(一)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2023-08-21T14:36:26.000Z" title="Created 2023-08-21 22:36:26">2023-08-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2023-08-21T15:50:13.126Z" title="Updated 2023-08-21 23:50:13">2023-08-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/">C#</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/%E9%AB%98%E9%A2%91%E8%AF%AD%E6%B3%95/">高频语法</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/C/%E9%AB%98%E9%A2%91%E8%AF%AD%E6%B3%95/%E9%9B%86%E5%90%88%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8F%8D%E5%B0%84%E3%80%81%E7%A8%8B%E5%BA%8F%E9%9B%86%E3%80%81%E7%89%B9%E6%80%A7/">集合、多线程、反射、程序集、特性</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C#高频语法集锦(一)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>@<a href="%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95">TOC</a></p>
<hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>搞编程的，基础不牢，地动山摇，多多复习哦，与诸君共勉。</p>
<h1 id="一、特征【ObsoleteAttribute】、程序"><a href="#一、特征【ObsoleteAttribute】、程序" class="headerlink" title="一、特征【ObsoleteAttribute】、程序"></a>一、特征【ObsoleteAttribute】、程序</h1><h2 id="1-Obsolete-“提示信息”-ture-false-：false-true代表是否停止编译，true代表。编译器发出错误提示并停止遍历，否则只发出提示信息不停止编译。提醒旧函数过时，使用新函数："><a href="#1-Obsolete-“提示信息”-ture-false-：false-true代表是否停止编译，true代表。编译器发出错误提示并停止遍历，否则只发出提示信息不停止编译。提醒旧函数过时，使用新函数：" class="headerlink" title="1.[Obsolete(“提示信息”, ture&#x2F;false)]：false&#x2F;true代表是否停止编译，true代表。编译器发出错误提示并停止遍历，否则只发出提示信息不停止编译。提醒旧函数过时，使用新函数："></a>1.[Obsolete(“提示信息”, ture&#x2F;false)]：false&#x2F;true代表是否停止编译，true代表。编译器发出错误提示并停止遍历，否则只发出提示信息不停止编译。提醒旧函数过时，使用新函数：</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C#">[<span class="hljs-meta">Obsolete(<span class="hljs-string">&quot;该函数已经过时，请使用新函数NewDoSomething()&quot;</span>, false)</span>]<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DoSomething</span>()</span><br>&#123;<br>    <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-NET中预定义了200多个特性，细致信息在System-Reflection命名空间中的类"><a href="#2-NET中预定义了200多个特性，细致信息在System-Reflection命名空间中的类" class="headerlink" title="2..NET中预定义了200多个特性，细致信息在System.Reflection命名空间中的类"></a>2..NET中预定义了200多个特性，细致信息在System.Reflection命名空间中的类</h2><ul>
<li>也可以自定义特性类，咱们用特征修饰哪个程序就用[]括起来放在程序前面。自定义的特性中的构造函数中的参数是必选参数，特性中的公有变量是可选参数</li>
<li>自定义特性时可以被其他特性修饰：<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> AttributeUsageAttribute类时专门修饰特性的特性，有AttributeTargets枚举，</span><br>用来规定特性可作用于哪些程序元素，可以用多个，中间用|连接；<br>有Inherited能否被继承；AllowMultiple表示能够对同一元素多次应用特性<br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>[<span class="hljs-meta">AttributeUsage(AttributeTargets.All, Inherited = true, AllowMultiple = true)</span>]<br><span class="hljs-keyword">internal</span>  <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span>&#123;<span class="hljs-comment">//...&#125;</span><br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-程序集：我们写好的代码最终都被编译器编译为很多程序集一种逻辑上的划分"><a href="#3-程序集：我们写好的代码最终都被编译器编译为很多程序集一种逻辑上的划分" class="headerlink" title="3.程序集：我们写好的代码最终都被编译器编译为很多程序集一种逻辑上的划分"></a>3.程序集：我们写好的代码最终都被编译器编译为很多程序集一种逻辑上的划分</h2><ul>
<li>两种最常见的程序集.exe和.dll<ul>
<li>.exe：可执行文件。有一个主程序入口，可运行</li>
<li>.dll：动态链接库文件。无主程序入口，不可运行，智能让其他程序调用</li>
</ul>
</li>
</ul>
<h1 id="二、反射：获取类型和程序集的信息-NET在System-Reflection命名空间中定义了一系列反射类，和System-Type类一起提供了反射功能"><a href="#二、反射：获取类型和程序集的信息-NET在System-Reflection命名空间中定义了一系列反射类，和System-Type类一起提供了反射功能" class="headerlink" title="二、反射：获取类型和程序集的信息.NET在System.Reflection命名空间中定义了一系列反射类，和System.Type类一起提供了反射功能"></a>二、反射：获取类型和程序集的信息.NET在System.Reflection命名空间中定义了一系列反射类，和System.Type类一起提供了反射功能</h1><ul>
<li>System.Reflection.Assembly类是为控制程序集【获取程序集元数据信息】而设计。在获取程序集元数据之前需要先用Assembly对象的Load()方法把程序集加载到内存</li>
<li>动态加载、动态调用、实现插件、System.Activator.CreateInstance(XxxType, null);XxxType代表咱们用.GetType获取的类，null代表构造函数的参数、xxx as xxx，强制类型转换，前面大后面小【强制类型转换是为了得到对象的方法，咱们也可以用Type.GetMethod(“欲调用方法名”)】</li>
</ul>
<h1 id="三、多线程"><a href="#三、多线程" class="headerlink" title="三、多线程"></a>三、多线程</h1><h2 id="1-创建一个线程："><a href="#1-创建一个线程：" class="headerlink" title="1.创建一个线程："></a>1.创建一个线程：</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C#">System.Threading.Thread：<br><span class="hljs-comment">//创建一个线程要三步骤：</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 创建线程三步骤的第一步：编写入口函数。线程需入口函数，可以通过委托机制编写入口函数传递给线程。C#中与工作线程的入口函数相关的委托是ThreadStart</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">EntryPointMethod</span>()</span><br>&#123;<br><br>&#125;<br><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 创建线程三步骤的第二步：创建入口委托。传递给线程的入口函数，必须是没有参数和返回值的函数</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">delegate</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ThreadStart</span>()</span>;<br>ThreadStart entryPoint = <span class="hljs-keyword">new</span> ThreadStart(EntryPointMethod);<br><br><span class="hljs-comment">//线程需入口函数，可以通过委托机制编写入口函数传递给线程。C#中与工作线程的入口函数相关的委托是ThreadStart</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> 创建线程三步骤的第三步：创建线程</span><br><span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>Thread WorkThread = <span class="hljs-keyword">new</span> Thread(entryPoint);<br><br>注意事项：除了用委托传递线程的入口函数之外，还可以通过匿名函数创建线程，将上面三个步骤合并为一步。并且解决了咱不能使用线程前面定义的变量，也就是入口函数没有参数和返回值的缺点<br>Thread DrawGraphThread = <span class="hljs-keyword">new</span> Thread(<span class="hljs-built_in">delegate</span>()<br>&#123;<br>        <span class="hljs-comment">//入口函数代码</span><br>&#125;<br>)<br></code></pre></td></tr></table></figure>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><code class="hljs C#">例子，<span class="hljs-keyword">namespace</span> <span class="hljs-title">WindowsFormsApp1</span><br>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">partial</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Form1</span> : <span class="hljs-title">Form</span><br>    &#123;<br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> Form1构造函数</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Form1</span>()</span><br>        &#123;<br>            InitializeComponent();<br>        &#125;<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 图形绘制函数</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 第一步：创建线程的入口函数</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">DrawGraph</span>()</span><br>        &#123;<br>            <span class="hljs-built_in">int</span> loop = <span class="hljs-number">0</span>;<br>            <span class="hljs-built_in">int</span> sect = <span class="hljs-number">0</span>;<br>            <span class="hljs-built_in">float</span>[] x = <span class="hljs-keyword">new</span> <span class="hljs-built_in">float</span>[<span class="hljs-number">31</span>];<br>            <span class="hljs-built_in">float</span>[] y = <span class="hljs-keyword">new</span> <span class="hljs-built_in">float</span>[<span class="hljs-number">31</span>];<br><br>            <span class="hljs-comment">//绘制图形10000遍，每隔200毫秒绘制一遍</span><br>            <span class="hljs-keyword">while</span> (loop &lt;= <span class="hljs-number">10000</span>)<br>            &#123;<br>                sect = (sect + <span class="hljs-number">1</span>) % <span class="hljs-number">25</span> + <span class="hljs-number">1</span>;<br><br>                <span class="hljs-comment">//绘制图形</span><br>                Graphics graphics = <span class="hljs-keyword">this</span>.CreateGraphics();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; sect; i++)<br>                &#123;<br>                    x[i] = ((<span class="hljs-built_in">float</span>)(<span class="hljs-number">150</span> * Math.Cos(i * <span class="hljs-number">2</span> * Math.PI / sect) + <span class="hljs-number">150</span>));<br>                    y[i] = (<span class="hljs-built_in">float</span>)(<span class="hljs-number">150</span> * Math.Sin(i * <span class="hljs-number">2</span> * Math.PI / sect) + <span class="hljs-number">150</span>);<br>                &#125;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> m = <span class="hljs-number">0</span>; m &lt; sect - <span class="hljs-number">1</span>; m++)<br>                &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> n = <span class="hljs-number">0</span>; n &lt; sect; n++)<br>                    &#123;<br>                        graphics.DrawLine(Pens.Blue, x[m], y[m], x[n], y[n]);<br>                    &#125;<br>                &#125;<br><br>                <span class="hljs-comment">//线程暂停200ms</span><br>                Thread.Sleep(<span class="hljs-number">200</span>);<br><br>                <span class="hljs-comment">//清除图形，以便重新绘制</span><br>                graphics.Clear(<span class="hljs-keyword">this</span>.BackColor);<br>                loop++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br><br>        <span class="hljs-meta">#<span class="hljs-keyword">region</span> 声明工作线程，并创建四个按钮的事件</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 声明工作线程</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        Thread DrawGraphThread;<br><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 开始按钮</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;sender&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;e&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startThreadButton_Click</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br>        &#123;<br>            <span class="hljs-comment">//第二步：创建入口委托</span><br>            ThreadStart entryPoint = <span class="hljs-keyword">new</span> ThreadStart(DrawGraph);<br><br>            <span class="hljs-comment"><span class="hljs-doctag">///</span>/第三步：创建线程，并启动线程</span><br>            <span class="hljs-comment">//new Thread(entryPoint).Start();</span><br><br>            <span class="hljs-comment">//第三步：创建线程</span><br>            DrawGraphThread = <span class="hljs-keyword">new</span> Thread(entryPoint);<br><br>            <span class="hljs-comment">//启动线程</span><br>            DrawGraphThread.Start();<br><br>            <span class="hljs-comment">//设置按钮的有效性</span><br>            startThreadButton.Enabled = <span class="hljs-literal">false</span>;<br>            suspendThreadButton.Enabled = <span class="hljs-literal">true</span>;<br>            resumeThreadButton.Enabled = <span class="hljs-literal">false</span>;<br>            abortThreadButton.Enabled = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 暂停按钮</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;sender&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;e&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">suspendThreadButton_Click</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br>        &#123;<br>            <span class="hljs-comment">//暂停线程。Suspend()和Abort()方法并不是立即停止线程，对于Suspend()方法，.NET会让线程再继续执行几个指令以确保线程在安全状态下挂起</span><br>            DrawGraphThread.Suspend();<br><br>            <span class="hljs-comment">//设置按钮的有效性</span><br>            suspendThreadButton.Enabled = <span class="hljs-literal">false</span>;<br>            resumeThreadButton.Enabled = <span class="hljs-literal">true</span>;<br>            abortThreadButton.Enabled = <span class="hljs-literal">false</span>;<br><br>        &#125;<br><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 恢复按钮</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;sender&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;e&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">resumeThreadButton_Click</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br>        &#123;<br>            <span class="hljs-comment">//恢复线程</span><br>            DrawGraphThread.Resume();<br><br>            <span class="hljs-comment">//设置按钮的有效性</span><br>            resumeThreadButton.Enabled = <span class="hljs-literal">false</span>;<br>            suspendThreadButton.Enabled = <span class="hljs-literal">true</span>;<br>            abortThreadButton.Enabled = <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> 中止按钮</span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;/summary&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;sender&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br>        <span class="hljs-comment"><span class="hljs-doctag">///</span> <span class="hljs-doctag">&lt;param name=&quot;e&quot;&gt;</span><span class="hljs-doctag">&lt;/param&gt;</span></span><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">abortThreadButton_Click</span>(<span class="hljs-params"><span class="hljs-built_in">object</span> sender, EventArgs e</span>)</span><br>        &#123;<br>            <span class="hljs-comment">// 中止线程.Suspend()和Abort()方法并不是立即停止线程，对于Suspend()方法，.NET会让线程再继续执行几个指令以确保线程在安全状态下挂起</span><br>            <span class="hljs-comment">//中止线程时Abort()方法会抛出一个ThreadAbortException异常，可以保证线程中止时如果正在执行try语句的代码，可以确保对应finally块被执行，然后确保相应资源被释放</span><br>            DrawGraphThread.Abort();<br><br>            <span class="hljs-comment">//设置按钮的有效性</span><br>            startThreadButton.Enabled = <span class="hljs-literal">true</span>;<br>            suspendThreadButton.Enabled = <span class="hljs-literal">false</span>;<br>            resumeThreadButton.Enabled = <span class="hljs-literal">false</span>;<br>            abortThreadButton.Enabled = <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-meta">#<span class="hljs-keyword">endregion</span></span><br>    &#125;<br></code></pre></td></tr></table></figure>

<h2 id="2-线程的优先级可以通过Thread-Priority设置设置，Priority属性是一个ThreadPriority型枚举，5个优先级"><a href="#2-线程的优先级可以通过Thread-Priority设置设置，Priority属性是一个ThreadPriority型枚举，5个优先级" class="headerlink" title="2.线程的优先级可以通过Thread.Priority设置设置，Priority属性是一个ThreadPriority型枚举，5个优先级"></a>2.线程的优先级可以通过Thread.Priority设置设置，Priority属性是一个ThreadPriority型枚举，5个优先级</h2><ul>
<li>没明确指定则两个线程优先级相同均为默认值Normal，所以交替执行【被执行的几率大概相等】。而且，在默认情况下，主线程Main和工作线程的优先级相同，也是交替进行</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-comment">//线程A</span><br>Thread ThreadA = <span class="hljs-keyword">new</span> Thread(<span class="hljs-built_in">delegate</span>()<br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100000000</span>; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (i % <span class="hljs-number">1000000</span> == <span class="hljs-number">0</span>)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&#x27;A&#x27;</span>);<br>        &#125;<br>    &#125;<br>&#125;);<br><br><span class="hljs-comment">//线程B</span><br>Thread ThreadB = <span class="hljs-keyword">new</span> Thread(<span class="hljs-built_in">delegate</span> ()<br>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt;= <span class="hljs-number">100000000</span>; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (i % <span class="hljs-number">1000000</span> == <span class="hljs-number">0</span>)<br>        &#123;<br>            Console.WriteLine(<span class="hljs-string">&#x27;B&#x27;</span>);<br>        &#125;<br>    &#125;<br>&#125;);<br><br><span class="hljs-comment">//启动线程</span><br>ThreadA.Start();<br>ThreadB.Start();<br></code></pre></td></tr></table></figure>
<ul>
<li>调整优先级后，只是说明优先级高的线程占有更多的CPU事件，cpu会执行哪个看CPU的心情</li>
</ul>
<h2 id="3-线程的同步：需要两个线程协同工作才能完成一项任务的情况，不协同最终结果就会出错"><a href="#3-线程的同步：需要两个线程协同工作才能完成一项任务的情况，不协同最终结果就会出错" class="headerlink" title="3.线程的同步：需要两个线程协同工作才能完成一项任务的情况，不协同最终结果就会出错"></a>3.线程的同步：需要两个线程协同工作才能完成一项任务的情况，不协同最终结果就会出错</h2><ul>
<li>多个线程共享的资源时临界资源；访问临界资源的代码叫做临界区；</li>
<li>一个例子：结果出错，用互锁、管程等修好<ul>
<li>运行结果有对有错，其实就是错的</li>
</ul>
</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-comment">//缓冲区</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">char</span> buffer;<br><br><br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        <span class="hljs-comment">//写线程</span><br>        Thread Writer = <span class="hljs-keyword">new</span> Thread(<span class="hljs-built_in">delegate</span> ()<br>        &#123;<br>            <span class="hljs-built_in">string</span> sentence = <span class="hljs-string">&quot;无可奈何花落去，似曾相识燕归来，i love min.&quot;</span>;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">24</span>; i++)<br>            &#123;<br>                buffer = sentence[i]; <span class="hljs-comment">//像缓冲区写入数据</span><br>                Thread.Sleep(<span class="hljs-number">26</span>);<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">//读线程</span><br>        Thread Reader = <span class="hljs-keyword">new</span> Thread(<span class="hljs-built_in">delegate</span> ()<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">24</span>; i++)<br>            &#123;<br>                <span class="hljs-built_in">char</span> ch = buffer; <span class="hljs-comment">//从缓冲区读数据</span><br>                Console.Write(ch);<br>                Thread.Sleep(<span class="hljs-number">20</span>);<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">//启动线程</span><br>        Writer.Start();<br>        Reader.Start();<br>    &#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>.NET框架保证线程同步的同步类【看下面例子】<ul>
<li>Interlocked互锁<ul>
<li>用Interlocked互锁的解决思路：为了实现同步，线程Writer在写入字符前先检查缓冲区满否？，满则等待，直到缓冲区数据被进程Reader读取；缓冲区空就写入，写入后就把缓冲区标记为满</li>
<li>numberOfUsedSpace计数器。通过System.Threading.Interlocked类控制计数器，实现进程的同步</li>
<li>运行结果完全正确</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-comment">//缓冲区</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">char</span> buffer;<br><br>    <span class="hljs-comment">//标识量（表示缓冲区已使用的空间，初始值为0）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">long</span> numberOfUsedSpace = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        <span class="hljs-comment">//写线程</span><br>        Thread Writer = <span class="hljs-keyword">new</span> Thread(<span class="hljs-built_in">delegate</span> ()<br>        &#123;<br>            <span class="hljs-built_in">string</span> sentence = <span class="hljs-string">&quot;无可奈何花落去，似曾相识燕归来，i love min.&quot;</span>;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">24</span>; i++)<br>            &#123;<br>                <span class="hljs-keyword">while</span> (Interlocked.Read(<span class="hljs-keyword">ref</span> numberOfUsedSpace) == <span class="hljs-number">1</span>)<br>                &#123;<br>                    Thread.Sleep(<span class="hljs-number">10</span>);<br>                &#125;<br><br><br>                buffer = sentence[i]; <span class="hljs-comment">//向缓冲区写入数据</span><br>                                      <span class="hljs-comment">//写入数据后把缓冲区标记为满</span><br>                Interlocked.Increment(<span class="hljs-keyword">ref</span> numberOfUsedSpace);<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">//读线程</span><br>        Thread Reader = <span class="hljs-keyword">new</span> Thread(<span class="hljs-built_in">delegate</span> ()<br>        &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">24</span>; i++)<br>            &#123;<br>                <span class="hljs-keyword">while</span> (Interlocked.Read(<span class="hljs-keyword">ref</span> numberOfUsedSpace) == <span class="hljs-number">0</span>)<br>                &#123;<br>                    Thread.Sleep(<span class="hljs-number">10</span>);<br>                &#125;<br><br>                <span class="hljs-built_in">char</span> ch = buffer; <span class="hljs-comment">//从缓冲区读数据</span><br>                Console.Write(ch);<br><br>                <span class="hljs-comment">//读取数据后把缓冲区标记为空</span><br>                Interlocked.Decrement(<span class="hljs-keyword">ref</span> numberOfUsedSpace);<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">//启动线程</span><br>        Writer.Start();<br>        Reader.Start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<pre><code>- Monitor管程
  - 用Monitor的解决思路：用独占锁方式控制线程同步，只有获得独占锁的线程才能访问临界资源。一线程进入临界区时先调用Monitor类的Enter()方法尝试获取临界资源的独占锁若独占锁已被其他线程占用这个线程就进入等待状态。前面线程在执行后面线程只能等待，睡在临界资源上。Monitor会记录所有睡在临界资源上的线程，执行完了退出临界区时需要调用Monitor.Pulse()方法唤醒睡眠在临界资源的线程
  - 运行结果完全正确：
</code></pre>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-comment">//缓冲区</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">char</span> buffer;<br><br>    <span class="hljs-comment">//用于同步的对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">object</span> lockForBuffer = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>();<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        <span class="hljs-comment">//写线程</span><br>        Thread Writer = <span class="hljs-keyword">new</span> Thread(<span class="hljs-built_in">delegate</span> ()<br>        &#123;<br>            <span class="hljs-built_in">string</span> sentence = <span class="hljs-string">&quot;无可奈何花落去，似曾相识燕归来，i love min.&quot;</span>;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++)<br>            &#123;<br>                <span class="hljs-keyword">try</span><br>                &#123;<br>                    <span class="hljs-comment">//进入临界区</span><br>                    Monitor.Enter(lockForBuffer);<br><br>                    buffer = sentence[i]; <span class="hljs-comment">//向缓冲区写入数据</span><br>                    <br>                    <span class="hljs-comment">//唤醒睡眠在临界资源上等待的线程</span><br>                    Monitor.Pulse(lockForBuffer);<br>                    <span class="hljs-comment">//让当前线程睡眠再临界资源上</span><br>                    Monitor.Wait(lockForBuffer);<br>                &#125;<br>                <span class="hljs-keyword">catch</span> (System.Threading.ThreadInterruptedException)<br>                &#123;<br><br>                    Console.WriteLine(<span class="hljs-string">&quot;Writer写线程被中止&quot;</span>); ;<br>                &#125;<br>                <span class="hljs-keyword">finally</span><br>                &#123;<br>                    <span class="hljs-comment">//退出临界区</span><br>                    Monitor.Exit(lockForBuffer);<br>                &#125;<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">//读线程</span><br>        Thread Reader = <span class="hljs-keyword">new</span> Thread(<span class="hljs-built_in">delegate</span> ()<br>        &#123;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++)<br>            &#123;<br>                <span class="hljs-keyword">try</span><br>                &#123;<br>                    <span class="hljs-comment">//进入临界区</span><br>                    Monitor.Enter(lockForBuffer);<br><br>                    <span class="hljs-comment">//从缓冲区读取数据</span><br>                    <span class="hljs-built_in">char</span> ch = buffer;<br>                    Console.Write(ch);<br><br>                    <span class="hljs-comment">//唤醒睡眠在临界资源上等待的线程</span><br>                    Monitor.Pulse(lockForBuffer);<br>                    <span class="hljs-comment">//让当前线程睡眠再临界资源上</span><br>                    Monitor.Wait(lockForBuffer);<br>                &#125;<br>                <span class="hljs-keyword">catch</span> (System.Threading.ThreadInterruptedException)<br>                &#123;<br><br>                    Console.WriteLine(<span class="hljs-string">&quot;Reader读线程被中止&quot;</span>); ;<br>                &#125;<br>                <span class="hljs-keyword">finally</span><br>                &#123;<br>                    <span class="hljs-comment">//退出临界区</span><br>                    Monitor.Exit(lockForBuffer);<br>                &#125;<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">//启动线程</span><br>        Writer.Start();<br>        Reader.Start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<pre><code>  - 注意事项：
    - Monitor类只能锁定引用类型对象而不能锁定值类型变量。这是因为当参数为值类型变量时，每调用依次Monitor.Enter()方法时值类型要进行一次装箱操作得到一个新Object对象，Monitor类不同操作用于不同对象是不能保证原子性的
    - 为确临界区时临界资源得到释放，应该在try中用Monitor类的代码并在finally中调用Monitor.Exit()方法
</code></pre>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">try</span><br>&#123;<br>      Monitor.Enter(要锁定的对象);<br>      <span class="hljs-comment">//临界区代码...</span><br>&#125;<br><span class="hljs-keyword">finally</span><br>&#123;<br>       Monitor.Exit(要锁定的对象);<br>&#125;<br><br>等价写法<br><span class="hljs-keyword">lock</span>(要锁定的对象)<br>&#123;<br>      <span class="hljs-comment">//临界区代码...</span><br>&#125;<br></code></pre></td></tr></table></figure>
<pre><code>    - 一个线程在某资源上放了一把锁，其他访问该资的线程只能暂停，程序效率降低，所以加锁之前想清楚
- Mutex互斥体
  - 排他性的使用共享资源，也就是一个资源一次只能被一个线程服务的过程或行为叫做线程间的互斥。互斥是一种特殊的线程同步。
  - 注意事项：
    - 和Monitor类似，只有获取Mutex对象所属权的线程才能进入临界区
    - 虽然用Mutex类要比使用Monitor类消耗更多的系统资源，但是用Mutex类可以跨越应用程序边界，在多个应用程序之间进行同步【系统互斥体】。还有局部互斥体，只能在创建Mutex对象的程序中用
</code></pre>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C#">在线程中创建互斥体：<br>Thread ThreadA = <span class="hljs-keyword">new</span> Thread(<span class="hljs-built_in">delegate</span>()<br>&#123;<br>        <span class="hljs-comment">//创建互斥体</span><br>        Mutex fileMutex = <span class="hljs-keyword">new</span> Mutex(<span class="hljs-literal">false</span>, <span class="hljs-string">&quot;MutexForTimeRecordFile&quot;</span>);<br>&#125;);<br>第一个参数代表创建者是否具有初始所属权，第二个参数代表互斥体的系统名称，<br>OS根据互斥体的系统名称辨别互斥体，只要有相同系统名称，就是同一个系统互斥体<br><br>创建完了后就是在trycatch语句中用了<br>...<br><span class="hljs-keyword">try</span><br>&#123;<br>      <span class="hljs-comment">//尝试请求互斥体的所属权，成则进入临界区，不成功则等待</span><br>      fileMutex.WaitOne();<br>      ...<br>&#125;<br>...<br><span class="hljs-keyword">finally</span><br>&#123;<br>       <span class="hljs-comment">//释放互斥体的所属权</span><br>       fileMutex.ReleaseMutex();<br>&#125;<br>...<br></code></pre></td></tr></table></figure>

<h2 id="4-死锁"><a href="#4-死锁" class="headerlink" title="4.死锁"></a>4.死锁</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs C#">解决方法：让两个或多个线程以相同顺序访问<br>临界资源即可<br><span class="hljs-keyword">internal</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Program</span><br>&#123;<br>    <span class="hljs-comment">//两个临界资源</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">object</span> A = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">object</span> B = <span class="hljs-keyword">new</span> <span class="hljs-built_in">object</span>();<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span>(<span class="hljs-params"><span class="hljs-built_in">string</span>[] args</span>)</span><br>    &#123;<br>        <span class="hljs-comment">//线程WriterThread</span><br>        Thread WriterThread = <span class="hljs-keyword">new</span> Thread(<span class="hljs-built_in">delegate</span>()<br>        &#123;<br>            <span class="hljs-comment">//以相同顺序访问临界资源，先拿A，再拿B</span><br>            <span class="hljs-keyword">lock</span> (A)<br>            &#123;<br>                <span class="hljs-keyword">lock</span> (B)<br>                &#123;<br>                    <span class="hljs-comment">//....</span><br>                &#125;<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">//线程ReaderThread</span><br>        Thread ReaderThread = <span class="hljs-keyword">new</span> Thread(<span class="hljs-built_in">delegate</span>()<br>        &#123;<br>            <span class="hljs-comment">//以相同顺序访问临界资源，先拿A，再拿B</span><br>            <span class="hljs-keyword">lock</span> (A)<br>            &#123;<br>                <span class="hljs-keyword">lock</span> (B)<br>                &#123;<br>                    <span class="hljs-comment">//....</span><br>                &#125;<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">//启动线程</span><br>        Writer.Start();<br>        Reader.Start();<br>    &#125;<br><br><br><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="5-线程池"><a href="#5-线程池" class="headerlink" title="5.线程池"></a>5.线程池</h2><ul>
<li>线程池：System.Threading.ThreadPool类，如果程序中包含很多简单不需要特殊控制的线程就可用ThreadPool类<ul>
<li>一个应用程序最多一个线程池，</li>
<li>如果向对线程进行更多特殊控制，就别用线程池。这三种情况不宜用ThreadPool类而用单独的Thread类<ul>
<li>线程执行很多时间</li>
<li>需要为线程指定详细的优先级</li>
<li>执行过程中需要对线程进行睡眠、挂起等操作</li>
</ul>
</li>
<li>.NET中线程池中线程数目默认最少1最多25可以用GetMaxThreads()、GetMinThreadsSetMaxThreads()、SetMinThreads()获取线程数目上限和下限</li>
</ul>
</li>
</ul>
<h1 id="四、集合"><a href="#四、集合" class="headerlink" title="四、集合"></a>四、集合</h1><h2 id="1-NET集合类【CL类库中】"><a href="#1-NET集合类【CL类库中】" class="headerlink" title="1..NET集合类【CL类库中】"></a>1..NET集合类【CL类库中】</h2><ul>
<li>System.Array类:优点是可按序找数，缺点是大小固定</li>
<li>System.Collections</li>
</ul>
<h2 id="2-IEnumerable接口，直接或间接实现了IEnumerable接口的类，在遍历时foreach会自动调用IEnumerable接口中的GetEnumerator-方法去获取元素。"><a href="#2-IEnumerable接口，直接或间接实现了IEnumerable接口的类，在遍历时foreach会自动调用IEnumerable接口中的GetEnumerator-方法去获取元素。" class="headerlink" title="2.IEnumerable接口，直接或间接实现了IEnumerable接口的类，在遍历时foreach会自动调用IEnumerable接口中的GetEnumerator()方法去获取元素。"></a>2.IEnumerable接口，直接或间接实现了IEnumerable接口的类，在遍历时foreach会自动调用IEnumerable接口中的GetEnumerator()方法去获取元素。</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C#">IEnumerable接口，直接或间接实现了IEnumerable接口的<br>类，在遍历时<span class="hljs-keyword">foreach</span>会自动调用IEnumerable接口中的<br>GetEnumerator()方法去获取元素。<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IEnumerable</span><br>&#123;<br>        <span class="hljs-function">IEnumerator  <span class="hljs-title">GetIEnumerator</span>()</span>;<span class="hljs-comment">//返回的实现了IEnumerator接口的对象就是迭代器</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">IEnumerator</span><br>&#123;<br>        <span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">MoveNext</span>()</span>; <span class="hljs-comment">// 获取下一个元素</span><br>        <span class="hljs-built_in">object</span> Currect&#123; <span class="hljs-keyword">get</span> ;&#125; <span class="hljs-comment">// 获取当前元素</span><br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Reset</span>()</span>; <span class="hljs-comment">// 将枚举数设置为其初始位置</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="3-IEnumerable-接口并不是我们看到的只有一个方法，它还有-4-个扩展方法。其中-Cast-和-OfType-这-2-个方法非常实用。而-OfType-比-Cast-更加强大，它除了进行强制转换外还可以实现类型的过滤。从结果中可以看到第一个-foreach-遇到-int-类型后由于无法转换而报出-InvalidCastException-异常，而使用-OfType-进行转换时则会自动进行类型筛选，遇到-int-类型的数据将不会转换，所以进行转换时-OfType-是首选"><a href="#3-IEnumerable-接口并不是我们看到的只有一个方法，它还有-4-个扩展方法。其中-Cast-和-OfType-这-2-个方法非常实用。而-OfType-比-Cast-更加强大，它除了进行强制转换外还可以实现类型的过滤。从结果中可以看到第一个-foreach-遇到-int-类型后由于无法转换而报出-InvalidCastException-异常，而使用-OfType-进行转换时则会自动进行类型筛选，遇到-int-类型的数据将不会转换，所以进行转换时-OfType-是首选" class="headerlink" title="3.IEnumerable 接口并不是我们看到的只有一个方法，它还有 4 个扩展方法。其中 Cast() 和 OfType() 这 2 个方法非常实用。而 OfType 比 Cast 更加强大，它除了进行强制转换外还可以实现类型的过滤。从结果中可以看到第一个 foreach 遇到 int 类型后由于无法转换而报出 InvalidCastException 异常，而使用 OfType 进行转换时则会自动进行类型筛选，遇到 int 类型的数据将不会转换，所以进行转换时 OfType 是首选"></a>3.IEnumerable 接口并不是我们看到的只有一个方法，它还有 4 个扩展方法。其中 Cast<T>() 和 OfType<T>() 这 2 个方法非常实用。而 OfType<T> 比 Cast<T> 更加强大，它除了进行强制转换外还可以实现类型的过滤。从结果中可以看到第一个 foreach 遇到 int 类型后由于无法转换而报出 InvalidCastException 异常，而使用 OfType<T> 进行转换时则会自动进行类型筛选，遇到 int 类型的数据将不会转换，所以进行转换时 OfType<T> 是首选</T></T></T></T></T></T></h2><hr>
<h1 id="巨人的肩膀"><a href="#巨人的肩膀" class="headerlink" title="巨人的肩膀"></a>巨人的肩膀</h1><ul>
<li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/zh-cn/dotnet/csharp/fundamentals/coding-style/coding-conventions">https://learn.microsoft.com/zh-cn/dotnet/csharp/fundamentals/coding-style/coding-conventions</a></li>
<li>菜鸟教程</li>
<li>C#高级编程</li>
<li>刘铁猛老师课程</li>
<li>公司组内的师傅们的苦口婆心的代码讲解</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="https://YWMHHBAIminminAI.gitee.io">Hu hb</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://ywmhhbaiminminai.gitee.io/2023/08/21/C-%E9%AB%98%E9%A2%91%E8%AF%AD%E6%B3%95%E9%9B%86%E9%94%A6-%E4%B8%80/">https://ywmhhbaiminminai.gitee.io/2023/08/21/C-%E9%AB%98%E9%A2%91%E8%AF%AD%E6%B3%95%E9%9B%86%E9%94%A6-%E4%B8%80/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C#</a><a class="post-meta__tags" href="/tags/%E9%AB%98%E9%A2%91%E8%AF%AD%E6%B3%95/">高频语法</a><a class="post-meta__tags" href="/tags/%E9%9B%86%E5%90%88/">集合</a><a class="post-meta__tags" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a><a class="post-meta__tags" href="/tags/%E5%8F%8D%E5%B0%84/">反射</a><a class="post-meta__tags" href="/tags/%E7%A8%8B%E5%BA%8F%E9%9B%86/">程序集</a><a class="post-meta__tags" href="/tags/%E7%89%B9%E6%80%A7/">特性</a></div><div class="post_share"><div class="social-share" data-image="/img/avatar.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> Donate</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/WeChat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/WeChat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/Alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/Alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/08/30/C-%E9%AB%98%E9%A2%91%E8%AF%AD%E6%B3%95%E9%9B%86%E9%94%A6-%E4%BA%8C/" title="C#高频语法集锦(二)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">C#高频语法集锦(二)</div></div></a></div><div class="next-post pull-right"><a href="/2023/08/20/C-%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C-%E9%81%87%E5%88%B0%E9%99%B7%E9%98%B1%E6%80%BB%E7%BB%93-%E4%B8%89/" title="C#编程经验/遇到陷阱总结(三)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">C#编程经验/遇到陷阱总结(三)</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2023/08/30/C-%E9%AB%98%E9%A2%91%E8%AF%AD%E6%B3%95%E9%9B%86%E9%94%A6-%E4%BA%8C/" title="C#高频语法集锦(二)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-30</div><div class="title">C#高频语法集锦(二)</div></div></a></div><div><a href="/2023/08/12/C-%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C-%E9%81%87%E5%88%B0%E7%9A%84bug%E5%8F%8A%E9%99%B7%E9%98%B1-%E4%B8%80/" title="C#编程经验&#x2F;遇到陷阱总结(一)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-12</div><div class="title">C#编程经验&#x2F;遇到陷阱总结(一)</div></div></a></div><div><a href="/2023/08/31/C-%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C-%E9%81%87%E5%88%B0%E7%9A%84bug%E5%8F%8A%E9%99%B7%E9%98%B1-%E5%9B%9B/" title="C-编程经验-遇到的bug及陷阱-四"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-31</div><div class="title">C-编程经验-遇到的bug及陷阱-四</div></div></a></div><div><a href="/2023/08/20/C-%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C-%E9%81%87%E5%88%B0%E9%99%B7%E9%98%B1%E6%80%BB%E7%BB%93-%E4%BA%8C/" title="C#编程经验&#x2F;遇到陷阱总结(二)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-20</div><div class="title">C#编程经验&#x2F;遇到陷阱总结(二)</div></div></a></div><div><a href="/2023/08/20/C-%E7%BC%96%E7%A8%8B%E7%BB%8F%E9%AA%8C-%E9%81%87%E5%88%B0%E9%99%B7%E9%98%B1%E6%80%BB%E7%BB%93-%E4%B8%89/" title="C#编程经验&#x2F;遇到陷阱总结(三)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-20</div><div class="title">C#编程经验&#x2F;遇到陷阱总结(三)</div></div></a></div><div><a href="/2023/08/06/CommonCSharpCodeConventions-C-%E4%BB%A3%E7%A0%81%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%E4%B8%80/" title="C#代码命名规范(一)"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-08-06</div><div class="title">C#代码命名规范(一)</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Hu hb</div><div class="author-info__description">寻寻觅觅，原来未来的你，在这里呀</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">47</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">74</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">61</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://gitee.com/aiminminai"><i class="Gitee"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:min221forever@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="https://github.com/YWMHHBAIminminAI" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="https://blog.csdn.net/m0_52436398?type=blog" target="_blank" title="CSDN"><i class="fa fa-book-open"></i></a><a class="social-icon" href="https://gitee.com/aiminminai" target="_blank" title="Gitee"><i class="fa fa-g"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content"><b><font color="#e66b6d">掬</font> <font color="#e66d98">水</font> <font color="#e66cc6">月</font> <font color="#cc6de6">在</font> <font        color="#9770e6">手</font> <font color="#6d93e6">，</font> <font color="#6fcde6">弄</font> <font color="#72e6b6">花</font> <font color="#72e689">香</font> <font color="#99e670">满</font> <font color="#cde670">衣</font> <p align="center"><img src="https://haiyong.site/img/img-blog.csdnimg.cn/f7384c88956d4378b72e47548e19c9f8.gif" width="50" alt="mao"></p> <p align="center">微信号：phone_15902953075</p> <p align="center">QQ号：1317957931</p></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%89%B9%E5%BE%81%E3%80%90ObsoleteAttribute%E3%80%91%E3%80%81%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.</span> <span class="toc-text">一、特征【ObsoleteAttribute】、程序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Obsolete-%E2%80%9C%E6%8F%90%E7%A4%BA%E4%BF%A1%E6%81%AF%E2%80%9D-ture-false-%EF%BC%9Afalse-true%E4%BB%A3%E8%A1%A8%E6%98%AF%E5%90%A6%E5%81%9C%E6%AD%A2%E7%BC%96%E8%AF%91%EF%BC%8Ctrue%E4%BB%A3%E8%A1%A8%E3%80%82%E7%BC%96%E8%AF%91%E5%99%A8%E5%8F%91%E5%87%BA%E9%94%99%E8%AF%AF%E6%8F%90%E7%A4%BA%E5%B9%B6%E5%81%9C%E6%AD%A2%E9%81%8D%E5%8E%86%EF%BC%8C%E5%90%A6%E5%88%99%E5%8F%AA%E5%8F%91%E5%87%BA%E6%8F%90%E7%A4%BA%E4%BF%A1%E6%81%AF%E4%B8%8D%E5%81%9C%E6%AD%A2%E7%BC%96%E8%AF%91%E3%80%82%E6%8F%90%E9%86%92%E6%97%A7%E5%87%BD%E6%95%B0%E8%BF%87%E6%97%B6%EF%BC%8C%E4%BD%BF%E7%94%A8%E6%96%B0%E5%87%BD%E6%95%B0%EF%BC%9A"><span class="toc-number">2.1.</span> <span class="toc-text">1.[Obsolete(“提示信息”, ture&#x2F;false)]：false&#x2F;true代表是否停止编译，true代表。编译器发出错误提示并停止遍历，否则只发出提示信息不停止编译。提醒旧函数过时，使用新函数：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-NET%E4%B8%AD%E9%A2%84%E5%AE%9A%E4%B9%89%E4%BA%86200%E5%A4%9A%E4%B8%AA%E7%89%B9%E6%80%A7%EF%BC%8C%E7%BB%86%E8%87%B4%E4%BF%A1%E6%81%AF%E5%9C%A8System-Reflection%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%B8%AD%E7%9A%84%E7%B1%BB"><span class="toc-number">2.2.</span> <span class="toc-text">2..NET中预定义了200多个特性，细致信息在System.Reflection命名空间中的类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%A8%8B%E5%BA%8F%E9%9B%86%EF%BC%9A%E6%88%91%E4%BB%AC%E5%86%99%E5%A5%BD%E7%9A%84%E4%BB%A3%E7%A0%81%E6%9C%80%E7%BB%88%E9%83%BD%E8%A2%AB%E7%BC%96%E8%AF%91%E5%99%A8%E7%BC%96%E8%AF%91%E4%B8%BA%E5%BE%88%E5%A4%9A%E7%A8%8B%E5%BA%8F%E9%9B%86%E4%B8%80%E7%A7%8D%E9%80%BB%E8%BE%91%E4%B8%8A%E7%9A%84%E5%88%92%E5%88%86"><span class="toc-number">2.3.</span> <span class="toc-text">3.程序集：我们写好的代码最终都被编译器编译为很多程序集一种逻辑上的划分</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%8F%8D%E5%B0%84%EF%BC%9A%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%A8%8B%E5%BA%8F%E9%9B%86%E7%9A%84%E4%BF%A1%E6%81%AF-NET%E5%9C%A8System-Reflection%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E4%B8%AD%E5%AE%9A%E4%B9%89%E4%BA%86%E4%B8%80%E7%B3%BB%E5%88%97%E5%8F%8D%E5%B0%84%E7%B1%BB%EF%BC%8C%E5%92%8CSystem-Type%E7%B1%BB%E4%B8%80%E8%B5%B7%E6%8F%90%E4%BE%9B%E4%BA%86%E5%8F%8D%E5%B0%84%E5%8A%9F%E8%83%BD"><span class="toc-number">3.</span> <span class="toc-text">二、反射：获取类型和程序集的信息.NET在System.Reflection命名空间中定义了一系列反射类，和System.Type类一起提供了反射功能</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">三、多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%EF%BC%9A"><span class="toc-number">4.1.</span> <span class="toc-text">1.创建一个线程：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87Thread-Priority%E8%AE%BE%E7%BD%AE%E8%AE%BE%E7%BD%AE%EF%BC%8CPriority%E5%B1%9E%E6%80%A7%E6%98%AF%E4%B8%80%E4%B8%AAThreadPriority%E5%9E%8B%E6%9E%9A%E4%B8%BE%EF%BC%8C5%E4%B8%AA%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">4.2.</span> <span class="toc-text">2.线程的优先级可以通过Thread.Priority设置设置，Priority属性是一个ThreadPriority型枚举，5个优先级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%EF%BC%9A%E9%9C%80%E8%A6%81%E4%B8%A4%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9C%E6%89%8D%E8%83%BD%E5%AE%8C%E6%88%90%E4%B8%80%E9%A1%B9%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%8C%E4%B8%8D%E5%8D%8F%E5%90%8C%E6%9C%80%E7%BB%88%E7%BB%93%E6%9E%9C%E5%B0%B1%E4%BC%9A%E5%87%BA%E9%94%99"><span class="toc-number">4.3.</span> <span class="toc-text">3.线程的同步：需要两个线程协同工作才能完成一项任务的情况，不协同最终结果就会出错</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%AD%BB%E9%94%81"><span class="toc-number">4.4.</span> <span class="toc-text">4.死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">4.5.</span> <span class="toc-text">5.线程池</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E9%9B%86%E5%90%88"><span class="toc-number">5.</span> <span class="toc-text">四、集合</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-NET%E9%9B%86%E5%90%88%E7%B1%BB%E3%80%90CL%E7%B1%BB%E5%BA%93%E4%B8%AD%E3%80%91"><span class="toc-number">5.1.</span> <span class="toc-text">1..NET集合类【CL类库中】</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-IEnumerable%E6%8E%A5%E5%8F%A3%EF%BC%8C%E7%9B%B4%E6%8E%A5%E6%88%96%E9%97%B4%E6%8E%A5%E5%AE%9E%E7%8E%B0%E4%BA%86IEnumerable%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%B1%BB%EF%BC%8C%E5%9C%A8%E9%81%8D%E5%8E%86%E6%97%B6foreach%E4%BC%9A%E8%87%AA%E5%8A%A8%E8%B0%83%E7%94%A8IEnumerable%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84GetEnumerator-%E6%96%B9%E6%B3%95%E5%8E%BB%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E3%80%82"><span class="toc-number">5.2.</span> <span class="toc-text">2.IEnumerable接口，直接或间接实现了IEnumerable接口的类，在遍历时foreach会自动调用IEnumerable接口中的GetEnumerator()方法去获取元素。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-IEnumerable-%E6%8E%A5%E5%8F%A3%E5%B9%B6%E4%B8%8D%E6%98%AF%E6%88%91%E4%BB%AC%E7%9C%8B%E5%88%B0%E7%9A%84%E5%8F%AA%E6%9C%89%E4%B8%80%E4%B8%AA%E6%96%B9%E6%B3%95%EF%BC%8C%E5%AE%83%E8%BF%98%E6%9C%89-4-%E4%B8%AA%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95%E3%80%82%E5%85%B6%E4%B8%AD-Cast-%E5%92%8C-OfType-%E8%BF%99-2-%E4%B8%AA%E6%96%B9%E6%B3%95%E9%9D%9E%E5%B8%B8%E5%AE%9E%E7%94%A8%E3%80%82%E8%80%8C-OfType-%E6%AF%94-Cast-%E6%9B%B4%E5%8A%A0%E5%BC%BA%E5%A4%A7%EF%BC%8C%E5%AE%83%E9%99%A4%E4%BA%86%E8%BF%9B%E8%A1%8C%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2%E5%A4%96%E8%BF%98%E5%8F%AF%E4%BB%A5%E5%AE%9E%E7%8E%B0%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BF%87%E6%BB%A4%E3%80%82%E4%BB%8E%E7%BB%93%E6%9E%9C%E4%B8%AD%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E7%AC%AC%E4%B8%80%E4%B8%AA-foreach-%E9%81%87%E5%88%B0-int-%E7%B1%BB%E5%9E%8B%E5%90%8E%E7%94%B1%E4%BA%8E%E6%97%A0%E6%B3%95%E8%BD%AC%E6%8D%A2%E8%80%8C%E6%8A%A5%E5%87%BA-InvalidCastException-%E5%BC%82%E5%B8%B8%EF%BC%8C%E8%80%8C%E4%BD%BF%E7%94%A8-OfType-%E8%BF%9B%E8%A1%8C%E8%BD%AC%E6%8D%A2%E6%97%B6%E5%88%99%E4%BC%9A%E8%87%AA%E5%8A%A8%E8%BF%9B%E8%A1%8C%E7%B1%BB%E5%9E%8B%E7%AD%9B%E9%80%89%EF%BC%8C%E9%81%87%E5%88%B0-int-%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E5%B0%86%E4%B8%8D%E4%BC%9A%E8%BD%AC%E6%8D%A2%EF%BC%8C%E6%89%80%E4%BB%A5%E8%BF%9B%E8%A1%8C%E8%BD%AC%E6%8D%A2%E6%97%B6-OfType-%E6%98%AF%E9%A6%96%E9%80%89"><span class="toc-number">5.3.</span> <span class="toc-text">3.IEnumerable 接口并不是我们看到的只有一个方法，它还有 4 个扩展方法。其中 Cast() 和 OfType() 这 2 个方法非常实用。而 OfType 比 Cast 更加强大，它除了进行强制转换外还可以实现类型的过滤。从结果中可以看到第一个 foreach 遇到 int 类型后由于无法转换而报出 InvalidCastException 异常，而使用 OfType 进行转换时则会自动进行类型筛选，遇到 int 类型的数据将不会转换，所以进行转换时 OfType 是首选</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B7%A8%E4%BA%BA%E7%9A%84%E8%82%A9%E8%86%80"><span class="toc-number">6.</span> <span class="toc-text">巨人的肩膀</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/19/%E4%BB%8ESOC%E8%B0%88%E8%B0%88%E7%A1%AC%E4%BB%B6%E4%B8%AD%E7%9A%84%E2%80%9C%E5%A4%8D%E7%94%A8%E2%80%9D%E4%B8%8E%E8%BD%AF%E4%BB%B6%E4%B8%AD%E7%9A%84%E2%80%9C%E5%A4%8D%E7%94%A8%E2%80%9D/" title="从SOC谈谈硬件中的“复用”与软件中的“复用”">从SOC谈谈硬件中的“复用”与软件中的“复用”</a><time datetime="2024-11-19T14:39:06.000Z" title="Created 2024-11-19 22:39:06">2024-11-19</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/18/ISP-PIPELINE-%E6%A6%82%E8%BF%B0/" title="ISP PIPELINE 概述">ISP PIPELINE 概述</a><time datetime="2024-11-18T15:13:33.000Z" title="Created 2024-11-18 23:13:33">2024-11-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/09/ISP-pipeline%E6%88%90%E5%83%8F%E9%93%BE%E8%B7%AF/" title="ISP pipeline成像链路">ISP pipeline成像链路</a><time datetime="2024-11-09T12:46:36.000Z" title="Created 2024-11-09 20:46:36">2024-11-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/09/%E9%A2%9C%E8%89%B2%E7%AE%97%E6%B3%95%E4%B9%8BHLR/" title="颜色算法之HLR">颜色算法之HLR</a><time datetime="2024-11-09T11:03:07.000Z" title="Created 2024-11-09 19:03:07">2024-11-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/11/09/%E9%A2%9C%E8%89%B2%E7%AE%97%E6%B3%95%E4%B9%8BCCM/" title="颜色算法之CCM">颜色算法之CCM</a><time datetime="2024-11-09T11:02:40.000Z" title="Created 2024-11-09 19:02:40">2024-11-09</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By Hu hb</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="chat-btn" type="button" title="Chat"><i class="fas fa-sms"></i></button><button id="go-up" type="button" title="Back To Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script>(() => {
  const isChatBtn = true
  const isChatHideShow = true

  if (isChatBtn) {
    const close = () => {
      Chatra('minimizeWidget')
      Chatra('hide')
    }

    const open = () => {
      Chatra('openChat', true)
      Chatra('show')
    }

    window.ChatraSetup = {
      startHidden: true
    }
  
    window.chatBtnFn = () => {
      const isShow = document.getElementById('chatra').classList.contains('chatra--expanded')
      isShow ? close() : open()
    }
  } else if (isChatHideShow) {
    window.chatBtn = {
      hide: () => {
        Chatra('hide')
      },
      show: () => {
        Chatra('show')
      }
    }
  }

  (function(d, w, c) {
    w.ChatraID = 't3Zijv5iKg5Z5HT6v'
    var s = d.createElement('script')
    w[c] = w[c] || function() {
        (w[c].q = w[c].q || []).push(arguments)
    }
    s.async = true
    s.src = 'https://call.chatra.io/chatra.js'
    if (d.head) d.head.appendChild(s)
  })(document, window, 'Chatra')

})()</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>